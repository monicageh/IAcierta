{"ast":null,"code":"// src/app/game/game.component.ts\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nimport { Component, HostListener, ViewChild, ElementRef } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { GameService } from '../services/game.service';\nimport { QuestionService } from '../services/question.service';\nlet GameComponent = class GameComponent {\n  constructor(router, gameService, questionService) {\n    this.router = router;\n    this.gameService = gameService;\n    this.questionService = questionService;\n    // flujo de preguntas\n    this.questions = [];\n    this.currentIndex = 0;\n    this.question = null;\n    // estado de cada pregunta: 'correct' | 'incorrect' | null\n    this.answerStatus = [];\n    // rosco\n    this.letters = [];\n    // respuesta / feedback\n    this.userAnswer = '';\n    this.showFeedback = false;\n    this.isCorrect = false;\n    // idioma\n    this.lang = 'es';\n    // propiedades de puntuación\n    this.playerScore = 0;\n    this.chatgptScore = 0;\n  }\n  ngOnInit() {\n    // 1) Recuperar idioma o volver a home\n    this.lang = this.gameService.getSelectedLang();\n    if (!this.lang) {\n      this.router.navigate(['/']);\n      return;\n    }\n    // 2) Cargar 25 preguntas aleatorias\n    this.questionService.startGame(this.lang).subscribe(list => {\n      this.questions = list;\n      this.answerStatus = new Array(this.questions.length).fill(null);\n      this.currentIndex = 0;\n      this.playerScore = 0;\n      this.loadCurrentQuestion();\n      this.generateRoscoLetters();\n    });\n  }\n  ngAfterViewInit() {\n    // recalcular posiciones si cambia tamaño\n    this.generateRoscoLetters();\n  }\n  onResize() {\n    this.generateRoscoLetters();\n  }\n  loadCurrentQuestion() {\n    this.question = this.questions[this.currentIndex];\n    this.userAnswer = '';\n    this.showFeedback = false;\n  }\n  /** Al pulsar “Comprobar” */\n  checkAnswer() {\n    if (!this.question) return;\n    this.questionService.checkAnswer(this.question.id, this.lang, this.userAnswer).subscribe(res => {\n      this.feedback = res;\n      this.isCorrect = res.correct;\n      if (res.correct) {\n        this.playerScore++;\n      }\n      if (res.chatgptCorrect) {\n        this.chatgptScore++;\n      }\n      // guardar estado\n      this.answerStatus[this.currentIndex] = res.correct ? 'correct' : 'incorrect';\n      this.showFeedback = true;\n    });\n  }\n  /** Al pulsar “Siguiente pregunta” */\n  nextQuestion() {\n    this.currentIndex++;\n    if (this.currentIndex < this.questions.length) {\n      this.loadCurrentQuestion();\n    } else {\n      this.exitGame();\n    }\n  }\n  /** Al pulsar “Salir” */\n  exitGame() {\n    this.gameService.clear();\n    this.playerScore = 0;\n    this.chatgptScore = 0;\n    this.router.navigate(['/']);\n  }\n  /** Calcula la posición de cada círculo */\n  generateRoscoLetters() {\n    const rect = this.roscoRef.nativeElement.getBoundingClientRect();\n    const outer = Math.min(rect.width, rect.height);\n    const center = outer / 2;\n    const circleSize = outer * 0.1;\n    const radius = center - circleSize / 2;\n    const total = this.questions.length;\n    this.letters = [];\n    for (let i = 0; i < total; i++) {\n      const angle = 360 / total * i - 90;\n      const rad = angle * Math.PI / 180;\n      const x = center + radius * Math.cos(rad) - circleSize / 2;\n      const y = center + radius * Math.sin(rad) - circleSize / 2;\n      this.letters.push({\n        index: i,\n        value: (i + 1).toString(),\n        x,\n        y,\n        size: circleSize\n      });\n    }\n  }\n  /** Devuelve sólo la parte de la pregunta tras el primer “:” */\n  get questionBody() {\n    if (!this.question) {\n      return '';\n    }\n    const text = this.question.pregunta || '';\n    const idx = text.indexOf(':');\n    // si hay “:”, devolvemos lo que viene después, quitando espacios\n    return idx >= 0 ? text.substring(idx + 1).trim() : text;\n  }\n};\n__decorate([ViewChild('roscoRef'), __metadata(\"design:type\", ElementRef)], GameComponent.prototype, \"roscoRef\", void 0);\n__decorate([HostListener('window:resize'), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], GameComponent.prototype, \"onResize\", null);\nGameComponent = __decorate([Component({\n  selector: 'app-game',\n  templateUrl: './game.component.html',\n  styleUrls: ['./game.component.css']\n}), __metadata(\"design:paramtypes\", [Router, GameService, QuestionService])], GameComponent);\nexport { GameComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}